{
  "name": "Multiplayer Game Development with Node.js, Socket.IO, and HTML5 Canvas (Stuyvesant Softdev 2016)",
  "tagline": "Multiplayer Game Development with Node.js, Socket.IO, and HTML5 Canvas (Stuyvesant Softdev 2016)",
  "body": "# Multiplayer Game Development with Node.js, Socket.IO, and HTML5 Canvas (Stuyvesant Softdev 2016)\r\nThis guide assumes you already know about object-oriented programming in JavaScript and object serialization. This is a high level overview on how to stitch together a multiplayer game from these elements and will be done entirely in JavaScript. You should have some familiarity with NodeJS servers as well. This guide will focus more on the high level structures needed to implement such a game and may leave out syntactical documentation. Resources for each of the elements needed will be linked if you need to learn the syntax for it.\r\n\r\n\r\n# Overview\r\nWe will be using NodeJS, Socket.IO, and the HTML5 Canvas to create a multiplayer JavaScript game. The control flow of this application is relatively straightforward. The server will act as a central relay that all clients will be connected to via WebSockets. Each client will send user input to the server, which is then processed and used to update the state of the entities/objects/players on the server. The server will be constantly sending back the state of the server so that the client can render it on the canvas.\r\n\r\n## Setup\r\nSince we have not discussed NodeJS in class, I will include a few quick scripts to help you set up your environment. I will not be discussing the specifics of Node and the V8 JavaScript engine, so check out the [NodeJS documentation](https://nodejs.org/api/) if you want to learn more about Node.\r\n```bash\r\n# Install nvm (Node Version Manager)\r\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash\r\n# Install NodeJS version 0.12.10\r\nnvm install 0.12.10\r\n# Make a directory for your project\r\n# You should also create any other necessary folders (/lib, /public, /views, etc)\r\nmkdir your_project\r\ncd your_project\r\nmkdir public\r\n# Initialize a node project (npm is the node package manager, analogous to pip for Python)\r\nnpm init\r\n# Install dependencies, will be using the ExpressJS framework for this guide.\r\nnpm install --save express socket.io\r\n```\r\nYour server.js app script should look something like this:\r\n(Please note that this is a stripped implementation for demo purposes and that you should take advantage of Express and templating engines if you actually build a project)\r\n```javascript\r\n// Dependencies.\r\nvar express = require('express');\r\nvar socketIO = require('socket.io');\r\n\r\n// Initialization.\r\nvar app = express();\r\nvar server = http.Server(app);\r\n\r\napp.set('port', 5000);\r\n\r\napp.use('/public',\r\n        express.static(__dirname + '/public'));\r\n\r\napp.use('/', function(request, response) {\r\n  response.sendFile(__dirname + '/index.html');\r\n});\r\n\r\n// Listener for packets that clients send.\r\nio.on('connection', function(socket) {\r\n  socket.on('from-client', function(data) {\r\n    console.log('Client ID: ' + socket.id);\r\n    console.log('Data from client: ' + data);\r\n  });\r\n});\r\n\r\n// Sends data to every connected client at 60 Hertz\r\nsetInterval(function() {\r\n  io.sockets.emit('from-server', {\r\n    data: 'DATA FROM SERVER'\r\n  });\r\n}, 1000 / 60);\r\n\r\n// Starts the server.\r\nserver.listen(5000, function() {\r\n  console.log('STARTING SERVER ON PORT ' + PORT_NUMBER);\r\n});\r\n```\r\nRun the server with the `node` command. Ex: `node server.js`  \r\nHere is a bare bones index.html that demonstrates the data transfer.\r\n```html\r\n<html>\r\n  <body>\r\n\r\n  <script src=\"/socket.io/socket.io.js\"></script>\r\n  <script>\r\n    var socket = io();\r\n    // Sends data to the server every second.\r\n    setInterval(function() {\r\n      socket.emit('from-client', {\r\n        data: \"DATA\"\r\n      });\r\n    }, 1000);\r\n\r\n    // Listens for data from the server and logs it when it receives it.\r\n    socket.on('from-server', function(data) {\r\n      console.log('Data from server ' + data);\r\n    });\r\n  </script>\r\n  </body>\r\n</html>\r\n```\r\nFor more information on Socket.IO, check out their [documentation](http://socket.io/docs) since this guide will not cover all the Socket.IO tips and tricks. I highly suggest you try building the example chat applications on their website so that you can understand WebSockets before you undertake game development.\r\n\r\n\r\n# Server/Client Structure\r\nOn the server side, implement a hashmap or use [this implementation](https://www.npmjs.com/package/hashmap) to store each player and their state in the game. You should have written a Player and a Game class to manage the internal state of the game. The server side will do no rendering, but each class should simply store all the abstract data pertinent to each entity, player, etc, such as position, velocity, damage, health, and so on. The server's sockets should have listeners set up to listen for data from the clients. Upon receiving data, the server will update its internal states. This should all be happening while the server is sending out the state of the game to all clients at a rate of approximately 60Hz.  \r\nOn the client side, you should set up socket listeners that receive the state of the game and display it on the canvas. The client side should have [event listeners for the keyboard and mouse events](https://codepad.co/snippet/IxpXWI52) so you can record and send them to the server. The example code above contains the emitters and listeners on both sides, so you can simply extend off of it and modify it to suit your needs.\r\n\r\n## Best Practices (Packet format)\r\nWhen sending and receiving data on both sides, use JSON objects as the format for your data.\r\n\r\n### Client side example\r\n```javascript\r\n/* --Other game code-- */\r\nvar mouseCoords = [];\r\ndocument.addEventListener('mousemove', function(event) {\r\n  mouseCoords = [event.offsetX, event.offsetY];\r\n});\r\n\r\n/**\r\n * This socket emit call can be put inside a game loop to constantly send data\r\n * to the server, you can also add more keys to the JSON object to send more\r\n * data, such as keyboard events, etc.\r\n */\r\nsocket.emit('user-input', {\r\n  mouse: mouseCoords\r\n});\r\n```\r\n\r\n### Server side example\r\n```javascript\r\n/* --Other server code-- */\r\nio.on('connection', function(socket) {\r\n  /**\r\n   * This listens for the user-input packet sent from the client side.\r\n   * The 'data' parameter in the callback is the JSON object that the\r\n   * client sent.\r\n   */\r\n  socket.on('user-input', function(data) {\r\n    // Output the mouse coordinate data to the console.\r\n    console.log(data.mouse);\r\n  });\r\n});\r\n```\r\nIn this example, I show how you emit user input from the client for processing on the server side. You will need to implement the complementary code that emits the server state to the clients, which listen for it and render it on the canvas. This should be trivial once you understand the concepts of Socket.IO.\r\n\r\n## Best Practices (Authoritative Determination)\r\nLet's say on your server you have entities with an x and a y position, and your client emits a packet that looks like this: `{ x: 100, y: 200 }`. On your server, you have:\r\n```javascript\r\n/* --Other server code-- */\r\nsocket.on('user-input', function(data) {\r\n  entity.x = data.x;\r\n  entity.y = data.y;\r\n});\r\n```\r\nCan you see why this might be problematic? This could very easily be exploited if someone typed\r\n```javascript\r\nsocket.emit('user-input', { x: 999999, y: 999999 });\r\n```\r\ninto the JavaScript console. The player's position can be completely controlled by the player. Generally it is good practice for multiplayer games to give the player *NO* control over their position. Instead, have the client emit the keyboard/mouse data, and leave the calculations up to the server. Here's another example of a problematic implementation, let's say the client emits a packet that now looks like this: `{ isMovingLeft: true, isMovingUp: false }`, and on your server, you have:\r\n```javascript\r\n/* --Other server code-- */\r\nsocket.on('user-input', function(data) {\r\n  if (data.isMovingLeft) {\r\n    entity.x += 5;\r\n  } else {\r\n    entity.x -= 5;\r\n  }\r\n  if (data.isMovingUp) {\r\n    entity.y += 5;\r\n  } else {\r\n    entity.y -= 5;\r\n  }\r\n});\r\n```\r\nThe line of code that would break this is also trivial:\r\n```javascript\r\nwhile (true) { socket.emit('user-input', { isMovingLeft: true, isMovingUp: false }); }\r\n```\r\nFaster computers with faster connections could send more packets per second that slower computers, causing their player entity to move significantly faster. Linking game/entity speed to packet refresh rate is generally not a good idea as well. Here is an ideal implementation, using the same packet as above:\r\n```javascript\r\n/* --Other server code-- */\r\nsocket.on('user-input', function(data) {\r\n  if (data.isMovingLeft) {\r\n    entity.vx = 5;\r\n  } else {\r\n    entity.vx = -5;\r\n  }\r\n  if (data.isMovingUp) {\r\n    entity.vy = 5;\r\n  } else {\r\n    entity.vy = -5;\r\n  }\r\n});\r\n\r\nsetInterval(function() {\r\n  entity.x += entity.vx;\r\n  entity.y += entity.vy;\r\n}, 1000 / 60);\r\n```\r\nWith this implementation, the packet refresh rate will not affect the speed of the game. Also, tampering with the packet will not allow the player to cheat. This concept of not giving the client control of anything is called **authoritative determination** and is good practice for multiplayer games to prevent cheating and other issues. It also reduces the amount of bug fixing headaches since all the game logic is confined to the server.\r\n\r\n## Best Practices (Tick Independent Game Loops)\r\nBy now, you're likely familiar with using functions like `setInterval()` or `window.requestAnimationFrame()` for your game loops. These functions generally provide stable FPS and update rate, but to ensure best performance, it is best to make your updates tick-independent, especially on the server (where you cannot use `window.requestAnimationFrame()`).\r\n```javascript\r\n/* --Other server code-- */\r\nvar vx = 5;\r\nsetInterval(function() {\r\n  entity.x += vx;\r\n}, 10);\r\n```\r\nIn this example, the server will move the entity by 5 units every 10 milliseconds. Let's say however, that on one particularly intensive tick, other computations chew through 500 milliseconds. In that time span, the entity has only moved 5 units, which will seem extremely unusual.\r\n```javascript\r\n/* --Other server code-- */\r\nvar vx = 5;\r\nvar lastUpdateTime = (new Date()).getTime();\r\nsetInterval(function() {\r\n  var currentTime = (new Date()).getTime();\r\n  var updateTimeDifference = (currentTime - lastUpdateTime) / 10;\r\n  entity.x += vx * updateTimeDifference;\r\n  lastUpdateTime = currentTime;\r\n}, 10);\r\n```\r\nAlthough contrived and ugly, this code will ensure a consistent update speed, which for certain games is of crucial importance, especially if the game implements some form of a physics engine. This implementation ties the update of the entities to time instead of the server ticks. This ensures that lag spikes or performance drops on the server will not overly impact the performance of each of the connected clients.\r\n\r\n# Created by @omgimanerd  \r\nCheck out some of my creations @penumbragames (They may take time to load as they are hosted on Heroku free tier). These games are all open source and their code is available to the public.  \r\n[Tank Anarchy](http://tankanarchy.herokuapp.com)  \r\n[Obsidio](http://obsidio.herokuapp.com)  \r\n[Git To The Hub](http://gittothehub.tech)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}